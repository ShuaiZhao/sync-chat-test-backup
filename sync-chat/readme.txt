Prerequisites
=============

This sync-chat package contains two sets of program. The first set is the ndnSIM code, and it can be compiled and built by following the steps in README.md file. The second set is "topo_gen.py", and this is a python script to generate topology file. To run this python script, a python library called "networkx" needs to be installed. For Ubuntu Users, networkx can be installed through 
"sudo apt-get install python-networkx"; it can also be downloaded from "networkx.github.io/download.html"

After you configure your ns-3 moduel, if you run into error code:
 # error while loading shared libraries: 
 # libns3-dev-network-debug.so: cannot open shared object file: No such file or directory
 you will need to run #sudo ldconfig

    
Notes
  if you compiled different version of ns-3 before, you need to clean all the ns3 related modules at /usr/lib/,
  /usr/local/lib,/ /usr/local/bin/, /usr/local/include then try to rebuild it again.
  
compling examples:
==================
  workspace/ndnsim-sync-chat/ns-3/
    ./waf clean
    ./waf configure -d debug
    ./waf 
    sudo ./waf install
  workspace/ndnsim-sync-chat/sync-chat/
    ./waf clean
    ./waf configure --debug ( it has to be same logging level with ns-3 compiling and installing)
    ./waf

      
Code Organization
==================

The code is organized by following the ndnSIM scenario template. 
./extentions/ : contains all new extended ndnSIM codes/modules/libraries, for the specific simulation scenario
./extentions/custom-apps/: all sync-chat related ndnSIM code can be found here
./results/log/: the log generated by the simulation is going here
./results/data/: the data files generated is going here
./topologies/: the topology file, network configuration file, topolgoy genertating script
 		       (topo_gen.py) can be found there. Note: topo_gen.py should be run in this directory.


Compile and Build
====================

The steps to compile and build the code can be found at ./README.md



Edit configuration file
==================

A network configuration is needed to run topo_gen.py, and this configuration file will provide network configuration information 
such as the number of routers, proxies, UEs in the network. 

For example:

$ cat config.txt
# This is a configuration file for a simulation scenario code
# The file provides configuration information about the network, and this information
# can be used to generate a topology file.
NumberOfUEs = 6
NumberOfProxies = 3
NumberOfRouters = 10
RoutersPerCluster = 3
UEsPerCluster = 2
ControllerPrefix = C
ProxyPrefix = P
UEPrefix = U
AccountPrefix = A

Note: 
NumberOfUEs: 		the totoal number of UEs running chat application
NumberOfProxies: 	the total number of proxies in the sync scheme
NumberOfRouters: 	the total number of routers in the core network
RoutersPerCluster: 	the number of routers in each local network, where the local network refers 			   	
  networks such as "enterprise network", "university network", etc.
UEsPerCluseter: 	the number of UEs in the local network. 
ControllerPrefix: 	The name prefix that is used to create the controller ID. Since there is 			
  	only one controller in our simulation, the controller ID is ControllerPrefix itself.
ProxyPrefix: 		The prefix of the proxyID. It is used to generate the proxyID. For example, 				
    if there is 3 proxies with prefix "P", the proxyId for each proxy will be 				"P1", "P2" and "P3".
UEPrefix:		The prefix of the UEID. It is used to generate the UEID. For example, 				
  if there is 3 UEs with prefix "U", the UEID for each proxy will be 				
    "U1", "U2" and "U3".
AccoutnPrefix:		The prefix of the accountID for the chat-room. One UE will use one account, 				
  so it is a one-to-one mapping between UE and account. The accountID and UEID 				
  are in the same pattern. (i.e. "A1", "A2", "A3", ...)


Run topo_gen.py
===============
Go into sync-chat folder
$ cd sync-chat
$ cd topologies
$ python topo_gen.py -r config.txt -w <topology file>


Users can edit on the file "config.txt", based on their own requirement on the network configuration, 
but the first column (the field names) should not be changed. 

topo_gen.py will read "config.txt", and create a random network that contains UEs, Proxies, and the controller. 

The topology information will be written into <topology file>, an example is given by test_topo.txt


Run simulation
===============

When the topology is generated, we can run the simulation. 
Go back to sync-chat folder, and enter into ./scenario/ directory. The following commands are the 
examples on how to run the simulation with network configuration file and generated topology. 
The simulation has known where the topology file is, so you do not have to identify the path of the topology and configuration file, 
just provide the file names. We output the result log file to the directory ./result/log. 


NS_LOG=syncChatApp ./waf "--run=topo-gen-example --ConfigInfo="config.txt" --TopoInfoFile="top o1.txt"" > results/log/topo1-app.tr 2>&1

NS_LOG= ./waf "--run=topo-gen-example --ConfigInfo="config.txt" --TopoInfoFile="topo1.txt"" > results/log/topo1-client.tr 2>&1


NS_LOG=SyncProxy ./waf "--run=topo-gen-example --ConfigInfo="config.txt" --TopoInfoFile="topo1.txt"" > results/log/topo1-proxy.tr 2>&1

NS_LOG=SyncController ./waf "--run=topo-gen-example --ConfigInfo="config.txt" --TopoInfoFile="topo1.txt"" > results/log/topo1-ctrler.tr 2>&1


run the whole system
========================
export 'NS_LOG=*=level_info|prefix_func|prefix_time'
export 'NS_LOG=SyncClient=level_info|prefix_func|prefix_time'
./waf "--run=sync-simulation --ConfigInfo="config.txt" --TopoInfoFile="topo1.txt" --SimulationTime=5.0" > results/log/topo1.tr 2>&1

export 'NS_LOG=syncChatApp=level_info|prefix_func|prefix_time'
./waf "--run=sync-simulation --ConfigInfo="config.txt" --TopoInfoFile="topo_test.txt" --SimulationTime=5" > results/log/topo_test.tr 2>&1

export 'NS_LOG=syncChatApp=level_all|prefix_func|prefix_time:SyncClient=level_all|prefix_func|prefix_time'

export 'NS_LOG=SyncAudioApp=level_info|prefix_func|prefix_time:SyncVideoApp=level_info|prefix_func|prefix_time'

export 'NS_LOG=SyncVideoApp=level_info|prefix_func|prefix_time'
export 'NS_LOG=SyncAudioApp=level_info|prefix_func|prefix_time'
export 'NS_LOG=SyncController=level_info|prefix_func|prefix_time'
export 'NS_LOG=SyncProxy=level_info|prefix_func|prefix_time'
export 'NS_LOG=SyncStartApp=level_info|prefix_func|prefix_time'


export 'NS_LOG=p2pAudioApp=level_info|prefix_func|prefix_time'
export 'NS_LOG=p2pChatApp=level_info|prefix_func|prefix_time'

export 'NS_LOG=syncChatApp=level_all|prefix_func|prefix_time:SyncAudioApp=level_info|prefix_func|prefix_time:SyncVideoApp=level_info|prefix_func|prefix_time'


./waf "--run=sync-simulation --ConfigInfo="config.txt" --TopoInfoFile="topo_2_proxies.txt" --SimulationTime=5" >  results/log/topo_2_proxies.tr 2>&1
NOTE:
  make sure that TopoInfoFile is the result of current config.txt (python topo_gen.py -r config.txt -w topo_text.txt)

Code Structure
===================

The structure of this simulation code set can be divided into two parts: digest-tree libarary, and simulation components.

1. Digest-tree library

This libarary contains three pieces: digest, digest-node, digest-tree
1.1 Digest (digest.h & digest.cc)
This class defines a struct ("DigestInfo") for the digest unit containing of three elements, 
which are "nodeId", "trackSeq" and "digestValue". The nodeId is the identifier of a specific 
node that will need it to construct the digest tree (i.e. sync-client, sync-proxy or sync-controller). 

There are several methods defined to operate on "DigestInfo", such as 
	- createDigestUnit
	- setDigest
	- getDigest
	- DigestSeqIncrement
	- RetrieveDigest
	- getDigestInfo
To manipulate on the digest value, openssl libaray is imported. 
(Note that some of the methods are modified on basis of the digest code from ChronoChat's sync library.) The relevant methods are:
	- createDigest
	- updateDigestValue
	- finalizeDigestValue
	- DestroyDigestValue
	- getHashValue
	- isZero
	- reset

1.2 DigestNode (digest-node.h & digest-node.cc)
This class defines the digest node that constructs the digest tree. For each digest node object, it contains a Digest object. 
Because the digest tree is a general tree that may have more than more than two branches, the DigestNode object has a pointer 
to its child node and a pointer to its sibling node, respectively.

1.3 DigestTree (digest-tree.h & digest-tree.cc)
This class defines a digest tree with relevant methods. This digest tree is a general tree, where a node may have more than
two children. The major methods defined to manipulate the digest tree are listed below:
	- BuildTree
	- GetRoot
	- GetData
	- InsertNode
	- UpdateTree
	- Traverse
	- CountChild
	- FindNode

2. Simulation components
We have designed a tree structure for distributing control messages to the network. 
There are three components: sync-client, sync-proxy and sync-controller. 
Besides this, an chat application that utilizes this sync-client to puch new update notification updates to the 
network is called sync-chat-app.

sync-chat-app: the application that periodically generate contents, and push a new content notification to the 
sync-client installed on the same node

sync-client: receives notificaitons from the application and generates new notification to the sync-proxy about 
the new content updates; it also receives notifications from proxies regarding updates from local domain or remote
 domains, and generates notifications to the application. 

sync-proxy: Pushes notification to both sync-clients and sync-controller when receiving a notification from
 sync-clients within local domains; pushes notification to clients when receiving notification from contrlller.

sync-controller: Pushes notification to all proxies when there is an update notification from one of the proxy. 

Note that: In current simulation, there is no network recovery scenario. For each component, more code blocks 
need to be added if recovery scenario is to be implemented. 
	
qoe-monitor
=============================================
 1655  CXXFLAGS="-Wall -ggdb -g3 -O0 -D__STDC_CONSTANT_MACROS"
 1656  CFLAGS="-Wall -ggdb -g3 -O0 -D__STDC_CONSTANT_MACROS"
 1657  LINKFLAGS="-L/usr/include/libavcodec -L/usr/include/libavformat/ -L/usr/include/libavutil -lavcodec -lavformat -lavutil"
 1658  echo $CXXFLAGS 
 1659  export CXXFLAGS="-Wall -ggdb -g3 -O0 -D__STDC_CONSTANT_MACROS"
 1660  echo $CXXFLAGS 
 1661  export CFLAGS="-Wall -ggdb -g3 -O0 -D__STDC_CONSTANT_MACROS"
 1662  export LINKFLAGS="-L/usr/include/libavcodec -L/usr/include/libavformat/ -L/usr/include/libavutil -lavcodec -lavformat -lavutil"
 1736  ./waf --run=qoe-monitor-example-1 --command-template="--dbg %s sample_mpeg4.mp4"
 1737  ./waf --run=qoe-monitor-example-1 --command-template="%s sample_mpeg4.mp4"

 1751  ffmpeg -i sample_3GPP2.3g2 -vcodec libx264 -preset ultrafast  -tune zerolatency output.mp4
 1752  ./waf --run=qoe-monitor-example-1 --command-template="%s output.mp4"








